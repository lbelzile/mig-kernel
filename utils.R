#' Simulate observations over a half-space
#'
#' The simulation study considers six different data generating mechanisms
#' for (mixtures of) elliptical distributions and skewed versions thereof,
#' defined on the half space generated by \code{beta}. The function returns
#' a sample of size \code{n} by \code{d}.
#' @param n sample size
#' @param model integer between 1 and 4 giving the data generating process
#' @param beta \code{d} vector of components defining the half-space
#' @return an \code{n} by \code{d} matrix of observations from the specified model
rsim <- function(n, model, beta) {
   d <- length(beta)
   model <- as.integer(model)
   Rcor <- function(a, d){
     stopifnot(a > -1/(d-1), a < 1)
     (diag(1-a, d, d) + matrix(a, d, d))
   }
   Omega <- switch(model,
                   diag(sqrt(1:d)) %*% Rcor(0.5, d) %*% diag(sqrt(1:d)),
                   Rcor(0.5, d), #diag(sqrt(d:1)) %*% Rcor(0.5, d) %*% diag(sqrt(d:1)),
                   Rcor(0.9, d),
                   Rcor(0.5, d))
   mu <- switch(model,
                beta + 0.1,
                1:d,
                rep(-1, d),
                rep(0.1, d ))
   mu2 <- beta + 10 - 1:d
   Omega2 <- diag(sqrt(1:d)) %*% Rcor(-0.2, d) %*% diag(sqrt(1:d))
   rsn_halfspace <- function(n, xi, beta, Omega, alpha) {

      affpars <- sn::affineTransSECdistr(
         object = sn::makeSECdistr(
            dp = list(xi = mu, Omega = Omega, alpha = alpha),
            family = "SN"),
         A = matrix(beta, ncol = 1),
         a = 0)
      accept <- 1-sn::psn(0, dp = affpars@dp)
      samp <- sn::rmsn(
         n = ceiling(1.2 * n / accept),
         xi = xi,
         Omega = Omega,
         alpha = alpha
      )
      x <- samp[samp %*% beta > 0,]
      nsim <- ceiling(1.2 * (n - nrow(x)) / accept)
      while (nrow(x) < n) {
         samp <- sn::rmsn(
            n = nsim,
            xi = xi,
            Omega = Omega,
            alpha = alpha
         )
         x <- rbind(x, samp[samp %*% beta > 0, ])
      }
      return(x[1:n, ])
   }
   stopifnot(model %in% 1:4)
   samp <- switch(
      model,
      rtellipt(
         n = n,
         beta = beta,
         mu = mu,
         sigma = Omega,
         df = 5
      ),
      rbind(
         rtellipt(
            n = n,
            beta = beta,
            mu = mu,
            sigma = Omega,
            df = 5
         )[(r <- runif(n) < 0.6), ],
         rtellipt(
            n = n,
            beta = beta,
            mu = mu2,
            sigma = Omega2
         )[!r, ]
      ),
      rsn_halfspace(
         n = n,
         xi = mu,
         beta = beta,
         Omega = Omega,
         alpha = rep(2, d)
      ),
      rmig(
         n = n,
         xi = mu,
         Omega = Omega,
         beta = beta
      )
   )
}

#' Density of the simulation study models
#'
#' @param x \code{n} by \code{d} matrix of observations
#' @param log logical; if \code{TRUE}, return a vector of log density
#' @inheritParams rsim
#' @return an \code{n} vector of log density or densities for \code{x}
dsim <- function(x, model, beta, log = TRUE) {
  d <- length(beta)
   model <- as.integer(model)
   stopifnot(model %in% 1:4)
   d <- length(beta)
   model <- as.integer(model)
   Rcor <- function(a, d){
     stopifnot(a > -1/(d-1), a < 1)
     (diag(1-a, d, d) + matrix(a, d, d))
   }
   Omega <- switch(model,
                   diag(sqrt(1:d)) %*% Rcor(0.5, d) %*% diag(sqrt(1:d)),
                   Rcor(0.5, d),#diag(sqrt(d:1)) %*% Rcor(0.5, d) %*% diag(sqrt(d:1)),
                   Rcor(0.9, d),
                   Rcor(0.5, d))
   mu <- switch(model,
                beta + 0.1,
                1:d,
                rep(-1, d),
                rep(0.1, d))
   mu2 <- beta + 10 - 1:d
   Omega2 <- diag(sqrt(1:d)) %*% Rcor(-0.2, d) %*% diag(sqrt(1:d))
  alpha <- rep(2, d)
  betamu <- sum(beta*mu)
  betaOm <- c(t(beta) %*% Omega %*% beta)
  # delta <- 1/sqrt(1 +  c(t(alpha) %*% Omega %*% alpha)) * c(Omega %*% alpha)
  # alphast <-  1/sqrt(betaOm - sum(beta*delta)^2) * sum(beta*delta)
  #
  # alpha_transfo <- function(A, xi, Omega, alpha){
  #    Omegax <- t(A) %*% Omega %*% A
  #    omegax <- diag(sqrt(diag(Omegax)), nrow = nrow(Omegax))
  #    Omegaz <- cov2cor(Omega)
  #    omega <- diag(sqrt(diag(Omega)), nrow = nrow(Omega))
  #    omegainv <- diag(1/sqrt(diag(Omega)), nrow = nrow(Omega))
  #    B <- omegainv %*% Omega %*% A
  #    omegax %*% solve(Omegax) %*% t(B) %*% alpha / sqrt(1 + t(alpha) %*% (Omegaz - B %*% solve(Omegax) %*% t(B)) %*% alpha)
  # }

  affpars <- sn::affineTransSECdistr(
     object = sn::makeSECdistr(
        dp = list(xi = mu, Omega = Omega, alpha = alpha),
        family = "SN"),
     A = matrix(beta, ncol = 1),
     a = 0)



  logdens <- switch(
      model,
      TruncatedNormal::dtmvt(
         x = x,
         log = TRUE,
         mu = mu,
         sigma = Omega,
         df = 5
      ) - TruncatedNormal::ptmvt(
         q = 0,
         mu = -betamu, # symmetry of elliptical distribution about the mean
         sigma = betaOm,
         df = 5,
         log = TRUE),
      log(0.6*exp(
         TruncatedNormal::dtmvt(
            x = x,
            beta = beta,
            mu = mu,
            sigma = Omega,
            df = 5, log = TRUE) -
         TruncatedNormal::ptmvt(
               q = 0,
               mu = -betamu, # symmetry of elliptical distribution about the mean
               sigma = betaOm,
               df = 5,
               log = TRUE)) +
         0.4 * exp(
            TruncatedNormal::dtmvnorm(x = x, mu = mu2, sigma = Omega2, log = TRUE) -
               TruncatedNormal::ptmvnorm(
                  q = 0,
                  mu = -sum(beta * mu2), # symmetry of elliptical distribution about the mean
                  sigma = t(beta) %*% Omega2 %*% beta,
                  log = TRUE))),
      sn::dmsn(x = x,
         xi = mu,
         Omega = Omega,
         alpha = alpha,
         log = TRUE
      ) - log(1-sn::psn(0, dp = affpars@dp)),
      dmig(
         x = x,
         xi = mu,
         Omega = Omega,
         beta = beta,
         log = TRUE)
   )
  if(log){
     return(logdens)
  } else{
     return(exp(logdens))
  }
}

#' Kullback-Leibler divergence and root integrated mean squared error between model and kernel density functions
#'
#' The function relies on generation of \code{N} vectors from the true model to approximate the KL divergence
#' and the root integrated mean squared error
#' @inheritParams rsim
#' @param bandwidth scale matrix for the MIG kernel density
#' @param N integer; number of simulations for which to compute the log density ratio
#' @return a scalar distance
metrics <- function(x, model, bandwidth, beta, N = 1e5L, kernel = c("mig","tnorm")){
  kernel <- match.arg(kernel)
  tsamp <- rsim(model = model, n = 1e5L, beta = beta)
  fx <- dsim(x = tsamp, model = model, beta = beta, log = TRUE)
  if(kernel == "mig"){
    fhatx <- mig::mig_kdens(x = x, newdata = tsamp, Omega = bandwidth, beta = beta, log = TRUE)
  } else{
    fhatx <- kdens_tnorm(x = x, newdata = tsamp, Sigma = bandwidth, beta = beta, log = TRUE)
  }
  c(rmise = sqrt(mean((exp(fx) - exp(fhatx))^2)),
    kldiv = mean(fx) - mean(fhatx))
}


#' Normal bandwidth rule
#'
#' Given an \code{n} by \code{d} matrix of observations, compute the
#' bandwidth according to Scott's rule.
#'
#' @param x \code{n} by \code{d} matrix of observations
#' @return a \code{d} by \code{d} diagonal bandwidth matrix
#' @keywords internal
#' @export
normalrule_bandwidth <- function(x){
  sigmas <- apply(x, 2, sd)
  n <- nrow(x)
  d <- ncol(x)
  (4/(d+2)/n)^(1/(d+4)) * diag(sigmas)
}
