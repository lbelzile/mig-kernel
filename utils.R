#' Simulate observations over a half-space
#'
#' The simulation study considers four different data generating mechanisms
#' for (mixtures of) elliptical distributions and skewed versions thereof,
#' defined on the half space generated by \code{beta}. The function returns
#' a sample of size \code{n} by \code{d}.
#' @param n sample size
#' @param model integer between 1 and 4 giving the data generating process
#' @param beta \code{d} vector of components defining the half-space
#' @return an \code{n} by \code{d} matrix of observations from the specified model
rsim <- function(n, model, beta) {
  d <- length(beta)
  model <- as.integer(model)
  Rcor <- function(a, d) {
    stopifnot(a > -1 / (d - 1), a < 1)
    (diag(1 - a, d, d) + matrix(a, d, d))
  }
  Omega <- switch(
    model,
    diag(sqrt(1:d)) %*% Rcor(0.5, d) %*% diag(sqrt(1:d)),
    Rcor(0.5, d),
    #diag(sqrt(d:1)) %*% Rcor(0.5, d) %*% diag(sqrt(d:1)),
    diag(sqrt(1:d)) %*% Rcor(0.9, d) %*% diag(sqrt(1:d)),
    Rcor(0.5, d)
  )
  if (model == 3L) {
    # Force symmetric matrix to be symmetric
    Omega[lower.tri(Omega)] = t(Omega)[lower.tri(Omega)]
  }
  mu <- switch(model, beta + 0.1, 1:d, rep(4, d), rep(2, d))
  mu2 <- beta + 10 - 1:d
  Omega2 <- diag(sqrt(1:d)) %*% Rcor(-0.2, d) %*% diag(sqrt(1:d))
  rsn_halfspace <- function(n, xi, beta, Omega, alpha) {
    affpars <- sn::affineTransSECdistr(
      object = sn::makeSECdistr(
        dp = list(
          xi = mu,
          Omega = Omega,
          alpha = alpha
        ),
        family = "SN"
      ),
      A = matrix(beta, ncol = 1),
      a = 0
    )
    accept <- 1 - sn::psn(0, dp = affpars@dp)
    samp <- sn::rmsn(
      n = ceiling(1.2 * n / accept),
      xi = xi,
      Omega = Omega,
      alpha = alpha
    )
    x <- samp[samp %*% beta > 0, ]
    nsim <- ceiling(1.2 * (n - nrow(x)) / accept)
    while (nrow(x) < n) {
      samp <- sn::rmsn(
        n = nsim,
        xi = xi,
        Omega = Omega,
        alpha = alpha
      )
      x <- rbind(x, samp[samp %*% beta > 0, ])
    }
    return(x[1:n, ])
  }
  stopifnot(model %in% 1:4)
  samp <- switch(
    model,
    rtellipt(
      n = n,
      beta = beta,
      mu = mu,
      sigma = Omega,
      df = 5
    ),
    rbind(
      rtellipt(
        n = n,
        beta = beta,
        mu = mu,
        sigma = Omega,
        df = 5
      )[(r <- runif(n) < 0.6), ],
      rtellipt(
        n = n,
        beta = beta,
        mu = mu2,
        sigma = Omega2
      )[!r, ]
    ),
    rsn_halfspace(
      n = n,
      xi = mu,
      beta = beta,
      Omega = Omega,
      alpha = rep(-5, d)
    ),
    rmig(
      n = n,
      xi = mu,
      Omega = Omega,
      beta = beta
    )
  )
}

#' Density of the simulation study models
#'
#' @param x \code{n} by \code{d} matrix of observations
#' @param log logical; if \code{TRUE}, return a vector of log density
#' @inheritParams rsim
#' @return an \code{n} vector of log density or densities for \code{x}
dsim <- function(x, model, beta, log = TRUE) {
  d <- length(beta)
  model <- as.integer(model)
  stopifnot(model %in% 1:4)
  d <- length(beta)
  model <- as.integer(model)
  Rcor <- function(a, d) {
    stopifnot(a > -1 / (d - 1), a < 1)
    (diag(1 - a, d, d) + matrix(a, d, d))
  }
  Omega <- switch(
    model,
    diag(sqrt(1:d)) %*% Rcor(0.5, d) %*% diag(sqrt(1:d)),
    Rcor(0.5, d),
    #diag(sqrt(d:1)) %*% Rcor(0.5, d) %*% diag(sqrt(d:1)),
    diag(sqrt(1:d)) %*% Rcor(0.9, d) %*% diag(sqrt(1:d)),
    Rcor(0.5, d)
  )
  mu <- switch(model, beta + 0.1, 1:d, rep(4, d), rep(2, d))
  mu2 <- beta + 10 - 1:d
  Omega2 <- diag(sqrt(1:d)) %*% Rcor(-0.2, d) %*% diag(sqrt(1:d))
  alpha <- rep(-5, d)
  betamu <- sum(beta * mu)
  betaOm <- c(t(beta) %*% Omega %*% beta)
  # delta <- 1/sqrt(1 +  c(t(alpha) %*% Omega %*% alpha)) * c(Omega %*% alpha)
  # alphast <-  1/sqrt(betaOm - sum(beta*delta)^2) * sum(beta*delta)
  #
  # alpha_transfo <- function(A, xi, Omega, alpha){
  #    Omegax <- t(A) %*% Omega %*% A
  #    omegax <- diag(sqrt(diag(Omegax)), nrow = nrow(Omegax))
  #    Omegaz <- cov2cor(Omega)
  #    omega <- diag(sqrt(diag(Omega)), nrow = nrow(Omega))
  #    omegainv <- diag(1/sqrt(diag(Omega)), nrow = nrow(Omega))
  #    B <- omegainv %*% Omega %*% A
  #    omegax %*% solve(Omegax) %*% t(B) %*% alpha / sqrt(1 + t(alpha) %*% (Omegaz - B %*% solve(Omegax) %*% t(B)) %*% alpha)
  # }

  affpars <- sn::affineTransSECdistr(
    object = sn::makeSECdistr(
      dp = list(
        xi = mu,
        Omega = Omega,
        alpha = alpha
      ),
      family = "SN"
    ),
    A = matrix(beta, ncol = 1),
    a = 0
  )



  logdens <- switch(
    model,
    TruncatedNormal::dtmvt(
      x = x,
      log = TRUE,
      mu = mu,
      sigma = Omega,
      df = 5
    ) - TruncatedNormal::ptmvt(
      q = 0,
      mu = -betamu,
      # symmetry of elliptical distribution about the mean
      sigma = betaOm,
      df = 5,
      log = TRUE
    ),
    log(
      0.6 * exp(
        TruncatedNormal::dtmvt(
          x = x,
          beta = beta,
          mu = mu,
          sigma = Omega,
          df = 5,
          log = TRUE
        ) -
          TruncatedNormal::ptmvt(
            q = 0,
            mu = -betamu,
            # symmetry of elliptical distribution about the mean
            sigma = betaOm,
            df = 5,
            log = TRUE
          )
      ) +
        0.4 * exp(
          TruncatedNormal::dtmvnorm(
            x = x,
            mu = mu2,
            sigma = Omega2,
            log = TRUE
          ) -
            TruncatedNormal::ptmvnorm(
              q = 0,
              mu = -sum(beta * mu2),
              # symmetry of elliptical distribution about the mean
              sigma = t(beta) %*% Omega2 %*% beta,
              log = TRUE
            )
        )
    ),
    sn::dmsn(
      x = x,
      xi = mu,
      Omega = Omega,
      alpha = alpha,
      log = TRUE
    ) - log(1 - sn::psn(0, dp = affpars@dp)),
    dmig(
      x = x,
      xi = mu,
      Omega = Omega,
      beta = beta,
      log = TRUE
    )
  )
  logdens <- ifelse(c(x %*% beta)  < 0, -Inf, logdens)
  if (log) {
    return(logdens)
  } else{
    return(exp(logdens))
  }
}

#' Mixture model simulation
#'
#' Simulate data from a mixture of \eqn{m} truncated Student-t centered at each data point, with
#' \code{m=nrow(xdat)}.
#'
#' @param n sample size
#' @param xdat matrix of observations at which to center mixtures
#' @param beta \code{d} vector of components defining the half-space
#' @param sigma scale matrix
rmixtths <- function(n, xdat, beta, sigma, df = 10L) {
  nc <- nrow(xdat)
  cat <- c(rmultinom(
    n = 1,
    size = n,
    prob = rep(1, nc)
  ))
  sim <- matrix(nrow = n, ncol = ncol(xdat))
  inds <- 0
  for (i in seq_along(cat)) {
    if (cat[i] > 0) {
      sim[(inds + 1):(inds + cat[i]), ] <- rtellipt(
        n = cat[i],
        beta = beta,
        mu = xdat[i, ],
        sigma = sigma,
        df = df
      )
      inds <- inds + cat[i]
    }
  }
  return(sim)
}


#' Density of Student mixture model
#'
#' @param x matrix of observations
#' @inheritParams rmixtths
dmixtths <- function(x, xdat, beta, sigma, df = 10) {
  rowMeans(apply(xdat, 1, function(xv) {
    dtellipt(
      x = x,
      beta = beta,
      mu = as.numeric(xv),
      sigma = sigma,
      df = df
    )
  }))
}

#' Kullback-Leibler divergence and root integrated mean squared error between model and kernel density functions
#'
#' The function relies on generation of \code{N} vectors from the true model to approximate the KL divergence
#' and the root integrated mean squared error
#' @inheritParams rsim
#' @param bandwidth scale matrix for the MIG kernel density
#' @param N integer; number of simulations for which to compute the log density ratio
#' @param metrics vector of character with the name of the criteria or metrics
#' @return a scalar distance
metrics <- function(x,
                    model,
                    bandwidth,
                    beta,
                    N = 1e5L,
                    kernel = c("mig", "tnorm", "hsgauss"),
                    metrics = c("rmise", "kldiv", "rwmise", "rbmise"),
                    delta = NULL) {
  kernel <- match.arg(kernel)
  mean_neg_log <- function(y0) {
    -min(y0) - log(length(y0)) +  log(sum(exp(-y0 + min(y0))))
  }
  n <- nrow(x)
  d <- length(beta)
  if(is.null(delta)){
   delta <- (n/d)^(-1/(d+4))
  }
  metrics <- match.arg(metrics,
                       choices = c("rmise", "kldiv", "rwmise", "rbmise"),
                       several.ok = TRUE)
  rmise <- kldiv <- rwmise <- rbmise <- NULL
  if(isTRUE(any(c("rwmise", "kldiv") %in% metrics))){
  nx <- rsim(model = model,
               n = N,
               beta = beta)
    logfx <- dsim(
      x = nx,
      model = model,
      beta = beta,
      log = TRUE
    )
    fx <- exp(logfx)
    if (kernel == "mig") {
      logfxhat <- mig::mig_kdens(
        x = x,
        newdata = nx,
        Omega = bandwidth,
        beta = beta,
        log = TRUE
      )
    } else if (kernel == "tnorm") {
      logfxhat <- mig::tnorm_kdens(
        x = x,
        newdata = nx,
        Sigma = bandwidth,
        beta = beta,
        log = TRUE
      )
    } else if (kernel == "hsgauss") {
      logfxhat <- mig::hsgauss_kdens(
        x = x,
        newdata = nx,
        Sigma = bandwidth,
        beta = beta,
        log = TRUE
      )
    }
    if("rwmise" %in% metrics){
      rwmise <- sqrt(mean((fx - exp(logfxhat))^2))
    } 
    if("kldiv" %in% metrics){
      kldiv <- mean(logfx) - mean(logfxhat)
    }
  }
  if(isTRUE(any(c("rmise", "rbmise") %in% metrics))){
    Pmat <- proj_hs(beta)
    # Kernel function
    kf <-  function(newdata,
                    x,
                    bandwidth,
                    beta,
                    log = TRUE,
                    kernel = c("mig", "tnorm", "hsgauss")) {
      kernel <- match.arg(kernel)
      if (kernel == "mig") {
        logfxhat <- mig::mig_kdens(
          x = matrix(x, ncol = length(beta)),
          newdata = matrix(newdata, ncol = length(beta)),
          Omega = bandwidth,
          beta = beta,
          log = log
        )
      } else if (kernel == "tnorm") {
        logfxhat <- mig::tnorm_kdens(
          x = matrix(x, ncol = length(beta)),
          newdata = matrix(newdata, ncol = length(beta)),
          Sigma = bandwidth,
          beta = beta,
          log = log
        )
      } else if (kernel == "hsgauss") {
        logfxhat <- mig::hsgauss_kdens(
          x = matrix(x, ncol = length(beta)),
          newdata = matrix(newdata, ncol = length(beta)),
          Sigma = bandwidth,
          beta = beta,
          log = log
        )
      }
      return(logfxhat)
    }
       cubature_mise <-  function(xnew, xdat, beta, bandwidth, kernel, Pmat) {
       # The following two calls are for "cubature" weird inputs
       if (length(xnew) == length(beta)) {
         xnew <- matrix(xnew, nrow = 1)
       }
       if(ncol(xnew) != length(beta)){
         xnew <- t(xnew)
       }
       xnew <- xnew %*% Pmat
       val <- rep(0, length = nrow(xnew))
       fx <- dsim(
         x = xnew,
         model = model,
         beta = beta,
         log = FALSE
       )
       fxhat <- kf(
         x = xdat,
         newdata = xnew,
         bandwidth = bandwidth,
         beta = beta,
         log = FALSE,
         kernel = kernel
       )
       val <- (fx - fxhat)^2
       return(matrix(val, ncol = 1))
     }
    if("rmise" %in% metrics){W
    mise_cub <- cubature::hcubature(
      f = cubature_mise,
      lowerLimit = c(0, rep(-Inf, d-1)), #bounds[1, ],
      upperLimit = rep(Inf, d),
      vectorInterface = TRUE,
      maxEval = 5e5L,
      absError = 1e-4,
      xdat = x,
      beta = beta,
      bandwidth = bandwidth,
      kernel = kernel,
      Pmat = Pmat
    )
    rmise <- sqrt(mise_cub$integral)
    }
    if("rbmise" %in% metrics){
    bmise_cub <- cubature::hcubature(
      f = cubature_mise,
      lowerLimit = c(0, rep(-Inf, d-1)), #bounds[1, ],
      upperLimit = c(delta, rep(Inf, d-1)),
      vectorInterface = TRUE,
      maxEval = 2e5L,
      absError = 1e-4,
      xdat = x,
      beta = beta,
      bandwidth = bandwidth,
      kernel = kernel,
      Pmat = Pmat
    )
       }
    rbmise <- sqrt(bmise_cub$integral)
  }
    return(
      c(
        kldiv = kldiv,
        rbmise = rbmise,
        rmise = rmise,
        rwmise = rwmise
    )[order(metrics)]
    )
  }



#' Kullback-Leibler divergence and root integrated mean squared error between model and kernel density functions
#'
#' The function relies on generation of \code{N} vectors from the true model to approximate the KL divergence
#' and the root integrated mean squared error
#' @inheritParams rsim
#' @param bandwidth scale matrix for the MIG kernel density
#' @param N integer; number of simulations for which to compute the log density ratio
#' @return a scalar distance
# metrics_backup <- function(x,
#                     model,
#                     bandwidth,
#                     beta,
#                     N = 1e5L,
#                     kernel = c("mig", "tnorm", "hsgauss"),
#                     method = c("is", "ismix", "cubature"),
#                     delta = 1) {
#   method <- match.arg(method)
#   kernel <- match.arg(kernel)
#   mean_neg_log <- function(y0) {
#     -min(y0) - log(length(y0)) +  log(sum(exp(-y0 + min(y0))))
#   }
#   d <- length(beta)
#   if (method == "is") {
#     nx <- rsim(model = model,
#                n = N,
#                beta = beta)
#     logfx <- dsim(
#       x = nx,
#       model = model,
#       beta = beta,
#       log = TRUE
#     )
#     fx <- exp(logfx)
#     if (kernel == "mig") {
#       logfxhat <- mig::mig_kdens(
#         x = x,
#         newdata = nx,
#         Omega = bandwidth,
#         beta = beta,
#         log = TRUE
#       )
#     } else if (kernel == "tnorm") {
#       logfxhat <- mig::tnorm_kdens(
#         x = x,
#         newdata = nx,
#         Sigma = bandwidth,
#         beta = beta,
#         log = TRUE
#       )
#     } else if (kernel == "hsgauss") {
#       logfxhat <- mig::hsgauss_kdens(
#         x = x,
#         newdata = nx,
#         Sigma = bandwidth,
#         beta = beta,
#         log = TRUE
#       )
#     }
#     rwmise <- sqrt(mean((fx - exp(logfxhat))^2))
#     ## Ionides truncation
#     # logw <- pmin(-logfx, 0.5*log(N) + meanw)
#     ## w <- pmin(1/fx, sqrt(N)*mean(1/fx))
#     ## PSIS
#     # logw <- loo::psis(-logfx)
#     # meanw <- mean_neg_log(logfx)
#     rmise <- sqrt(mean(fx - 2 * exp(logfxhat) + exp(2 * logfxhat - logfx)) /
#                     mean(exp(-logfx)))
#     ndl <- c(nx %*% beta) < delta
#     rbmise <- sqrt(mean((
#       fx - 2 * exp(logfxhat) + exp(2 * logfxhat - logfx)
#     )[ndl]) / mean(exp(-logfx[ndl])))
#     # mise <- weighted.mean((fx - exp(logfxhat))^2, w = exp(logw))
#     kldiv <- mean(logfx) - mean(logfxhat)
#     return(c(
#       rwmise = rwmise,
#       rbmise = rbmise,
#       rmise = rmise,
#       kldiv = kldiv,
#       nb = sum(ndl)
#     ))
#   } else if (method == "ismixt") {
#     nk <- rbinom(n = 1,
#                  size = N,
#                  prob = c(0.5, 0.5))
#     tsamp <- rbind(
#       rsim(
#         model = model,
#         n = nk,
#         beta = beta
#       ),
#       rmixtths(
#         n = N - nk,
#         xdat = x,
#         beta = beta,
#         sigma = bandwidth
#       )
#     )
#     logfx <- dsim(
#       x = tsamp,
#       model = model,
#       beta = beta,
#       log = TRUE
#     )
#     if (kernel == "mig") {
#       logfxhat <- mig::mig_kdens(
#         x = x,
#         newdata = tsamp,
#         Omega = bandwidth,
#         beta = beta,
#         log = TRUE
#       )
#     } else if (kernel == "tnorm") {
#       logfxhat <- mig::tnorm_kdens(
#         x = x,
#         newdata = tsamp,
#         Sigma = bandwidth,
#         beta = beta,
#         log = TRUE
#       )
#     } else if (kernel == "hsgauss") {
#       logfxhat <- mig::hsgauss(
#         x = x,
#         newdata = tsamp,
#         Sigma = bandwidth,
#         beta = beta,
#         log = TRUE
#       )
#     }
#     gx <- 0.5 * exp(logfx) + 0.5 * dmixtths(
#       x = tsamp,
#       xdat = x,
#       beta = beta,
#       sigma = bandwidth
#     )
#     mg <- mean(1 / gx)
#     mise <- sqrt(mean(exp(2 * log(abs(
#       exp(logfx) - exp(logfxhat)
#     )) - log(gx))) / mg)
#     rwmise <- sqrt(mean(exp(2 * log(abs(
#       exp(logfx) - exp(logfxhat)
#     )) + logfx - log(gx))) / mg)
#     ndl <- c(tsamp %*% beta) < delta
#     rbmise <- sqrt(mean(((
#       fx - 2 * exp(logfxhat) + exp(2 * logfxhat - logfx)
#     ) / gx)[ndl]) / mean(1 / gx[ndl]))
#     kldiv <- mean((logfx - logfxhat) * exp(logfx - log(gx))) / mg
#     return(c(
#       rwmise = rwmise,
#       rbmise = rbmise,
#       rmise = rmise,
#       kldiv = kldiv,
#       nb = sum(ndl)
#     ))
#   } else if (method %in% c("cubature","quadrature")) {
#     Pmat <- proj_hs(beta)
#     # Kernel function
#     kf <-  function(newdata,
#                     x,
#                     bandwidth,
#                     beta,
#                     log = TRUE,
#                     kernel = c("mig", "tnorm", "hsgauss")) {
#       kernel <- match.arg(kernel)
#       if (kernel == "mig") {
#         logfxhat <- mig::mig_kdens(
#           x = matrix(x, ncol = length(beta)),
#           newdata = matrix(newdata, ncol = length(beta)),
#           Omega = bandwidth,
#           beta = beta,
#           log = log
#         )
#       } else if (kernel == "tnorm") {
#         logfxhat <- mig::tnorm_kdens(
#           x = matrix(x, ncol = length(beta)),
#           newdata = matrix(newdata, ncol = length(beta)),
#           Sigma = bandwidth,
#           beta = beta,
#           log = log
#         )
#       } else if (kernel == "hsgauss") {
#         logfxhat <- mig::hsgauss(
#           x = matrix(x, ncol = length(beta)),
#           newdata = matrix(newdata, ncol = length(beta)),
#           Sigma = bandwidth,
#           beta = beta,
#           log = log
#         )
#       }
#       return(logfxhat)
#     }
#     if (method == "quadrature") {
#       # Need to do the numerical integration avoiding points
#       # outside the half-space
#       quadrature_mise <-  function(xnew, xdat, beta, bandwidth, kernel, Pmat) {
#         xnew <- xnew %*% t(Pmat) # project so that first component is positive
#         ind <- c(xnew[,1] > 0)
#         val <- rep(0, length = nrow(xnew))
#         fx <- dsim(
#           x = xnew[ind, ],
#           model = model,
#           beta = beta,
#           log = FALSE
#         )
#         fxhat <- kf(
#           x = xdat,
#           newdata = xnew[ind, ],
#           bandwidth = bandwidth,
#           beta = beta,
#           log = FALSE,
#           kernel = kernel
#         )
#         val[ind] <- (fx - fxhat)^2
#         return(val)
#       }
#
#       quadrature_KLD <-  function(xnew, xdat, beta, bandwidth, Pmat) {
#         xnew <- xnew %*% t(Pmat)
#         ind <- c(xnew[,1] > 0)
#         val <- rep(0, length = nrow(xnew))
#         logfx <- dsim(
#           x = xnew[ind, , drop = FALSE],
#           model = model,
#           beta = beta,
#           log = TRUE
#         )
#         logfxhat <- kf(
#           x = xdat,
#           newdata = xnew[ind, , drop = FALSE],
#           bandwidth = bandwidth,
#           beta = beta,
#           log = TRUE,
#           kernel = kernel
#         )
#         val[ind] <- (logfx - logfxhat) * exp(logfx)
#         val[!is.finite(val)] <- 0
#         return(val)
#       }
#       nw <- mvQuad::createNIGrid(dim = d,
#                                  type = "nHe",
#                                  level = 12)
#       # Shift grid
#       mvQuad::rescale(nw,
#                       m = colMeans(x %*% Pmat),
#                       C = diag(d))
#       mise_quad <- mvQuad::quadrature(
#         quadrature_mise,
#         xdat = x,
#         beta = beta,
#         bandwidth = bandwidth,
#         grid = nw,
#         kernel = kernel,
#         Pmat = Pmat
#       )
#       KLD_quad <- mvQuad::quadrature(
#         quadrature_KLD,
#         xdat = x,
#         beta = beta,
#         bandwidth = bandwidth,
#         grid = nw,
#         kernel = kernel
#       )
#       c(rmise = sqrt(mise_quad), kldiv = KLD_quad)
#
#
#     } else if(method == "cubature"){
#       cubature_mise <-  function(xnew, xdat, beta, bandwidth, kernel, Pmat) {
#         # The following two calls are for "cubature" weird inputs
#         if (length(xnew) == length(beta)) {
#           xnew <- matrix(xnew, nrow = 1)
#         }
#         if(ncol(xnew) != length(beta)){
#           xnew <- t(xnew)
#         }
#         xnew <- xnew %*% Pmat
#         val <- rep(0, length = nrow(xnew))
#         fx <- dsim(
#           x = xnew,
#           model = model,
#           beta = beta,
#           log = FALSE
#         )
#         fxhat <- kf(
#           x = xdat,
#           newdata = xnew,
#           bandwidth = bandwidth,
#           beta = beta,
#           log = FALSE,
#           kernel = kernel
#         )
#         val <- (fx - fxhat)^2
#         return(matrix(val, ncol = 1))
#       }
#       cubature_kld <-  function(xnew, xdat, beta, bandwidth, kernel, Pmat) {
#         # The following two calls are for "cubature" weird inputs
#         if (length(xnew) == length(beta)) {
#           xnew <- matrix(xnew, nrow = 1)
#         }
#         if(ncol(xnew) != length(beta)){
#           xnew <- t(xnew)
#         }
#         xnew <- xnew %*% Pmat
#         val <- rep(0, length = nrow(xnew))
#         logfx <- dsim(
#           x = xnew,
#           model = model,
#           beta = beta,
#           log = TRUE
#         )
#         logfxhat <- kf(
#           x = xdat,
#           newdata = xnew,
#           bandwidth = bandwidth,
#           beta = beta,
#           log = TRUE,
#           kernel = kernel
#         )
#         val <- (logfx - logfxhat) * exp(logfx)
#         val[!is.finite(val)] <- 0
#         return(matrix(val, ncol = 1))
#       }
#
#
#
#       mise_cub <- cubature::hcubature(
#         f = cubature_mise,
#         lowerLimit = c(0, rep(-Inf, d-1)), #bounds[1, ],
#         upperLimit = rep(Inf, d),
#         vectorInterface = TRUE,
#         maxEval = 5e5L,
#         # absError = 1e-6,
#         xdat = x,
#         beta = beta,
#         bandwidth = bandwidth,
#         kernel = kernel,
#         Pmat = Pmat
#       )
#       bmise_cub <- cubature::hcubature(
#         f = cubature_mise,
#         lowerLimit = c(0, rep(-Inf, d-1)), #bounds[1, ],
#         upperLimit = c(1, rep(Inf, d-1)),
#         vectorInterface = TRUE,
#         maxEval = 2e5L,
#         # absError = 1e-6,
#         xdat = x,
#         beta = beta,
#         bandwidth = bandwidth,
#         kernel = kernel,
#         Pmat = Pmat
#       )
#       KLD_cub <- suppressWarnings(cubature::pcubature(
#         f = cubature_kld,
#         lowerLimit = c(0, rep(-Inf, d-1)),
#         upperLimit = rep(Inf, d),
#         vectorInterface = TRUE,
#         maxEval = 2e5L,
#         xdat = x,
#         beta = beta,
#         bandwidth = bandwidth,
#         kernel = kernel,
#         Pmat = Pmat
#       ))
#       c(rmise = sqrt(mise_cub), kldiv = KLD_cub, rbmise = sqrt(bmise_cub))
#     }
#   }
# }


doOne <- function(n, model, d, method = 0:17, criterion,  ...) {
  # library(mig)
  # n = 250L; model = 1L; d = 3L
  # source("~/Documents/Dropbox/Publications/Submitted/MIG/_code/utils.R")
  # set.seed(1234)
  # doOne(n = 250, model = 3, d = 2)
  tmax <- 120L
  maxiter = 2500L
  beta <- rep(1, d)
  samp <- rsim(n = n, beta = beta, model = model)
  criterion <- match.arg(criterion, choices = c("rmise", "kldiv", "rwmise", "rbmise", "timing"), several.ok = TRUE)
  ctime <- which(criterion == "timing")
  criteria <- matrix(NA, nrow = length(method), ncol = length(criterion))
  # stopifnot(isTRUE(all(method %in% 1:10)))
  options <- rbind(
    #method, type, transformation, family, approx
    c("lcv", "full", "none", "mig","kernel"),    # 1
    c("amise", "full", "none", "mig","mig"),    # 2
    c("rlcv", "full", "none", "mig","kernel"),    # 3
    c("lscv", "full", "none", "mig","kernel"),    # 4
    c("lcv", "isotropic", "spherical", "mig","kernel"),    # 5
    c("amise", "isotropic", "spherical", "mig","mig"),    # 6
    c("rlcv", "isotropic", "spherical", "mig","kernel"),    # 7
    c("lscv", "isotropic", "spherical", "mig","kernel"),    # 8
    c("lcv", "diag", "none", "hsgauss","kernel"),    # 9
    c("rlcv", "diag", "none", "hsgauss","kernel"),    # 10
    c("lscv", "diag", "none", "hsgauss","kernel"),    # 11
    c("lcv", "full", "none", "tnorm","kernel"),    # 12
    c("rlcv", "full", "none", "tnorm","kernel"),    # 13
    c("lscv", "full", "none", "tnorm","kernel"),    # 14
    c("lcv", "isotropic", "spherical", "tnorm","kernel"),    # 15
    c("rlcv", "isotropic", "spherical", "tnorm","kernel"),    # 16
    c("lscv", "isotropic", "spherical", "tnorm","kernel")) # 17
  colnames(options) <- c("method", "type", "transformation", "family","approx")
  args <- list(
    x = samp,
    beta = beta,
    maxiter = maxiter
  )
  index <- 0L
  for (i in method[method %in% 1:17]) {
    index <- index + 1L
    time1 <- Sys.time()
    bw <- try(do.call(what = kdens_bandwidth,
                      args = c(args, options[i, ])),
              silent = TRUE)
    time2 <- Sys.time()
    if (is.matrix(bw) & !isTRUE(any(is.na(bw)))) {
      criteria[index, setdiff(1:length(criterion), ctime)] <- metrics(
        x = samp,
        model = model,
        bandwidth = bw,
        kernel = options[i, "family"],
        beta = beta,
        metrics = criterion,
        N = 1e4L
      )
      if(length(ctime) == 1L){
       criteria[index, ctime] <- as.numeric(time2 - time1)
      }
    }
  }
  if (0 %in% method) {
    bwnorm <- diag(apply(samp, 2, sd)) * exp((log(4) - log(d + 2) - log(n)) / (d + 4))
    criteria[index + 1L,  setdiff(1:length(criterion), ctime)] <- 
      metrics(
        x = samp,
        model = model,
        kernel = "mig",
        bandwidth = bwnorm,
        metrics = criterion,
        beta = beta,
        N = 1e4L)
  }
  criteria
}


